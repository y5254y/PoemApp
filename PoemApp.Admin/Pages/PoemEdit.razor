@page "/poems/edit/{Id:int}"
@attribute [Authorize(Roles = "Admin")]
@using PoemApp.Admin.Services
@using PoemApp.Core.DTOs
@using PoemApp.Core.Enums
@using PoemApp.Core.Extensions
@using Microsoft.AspNetCore.Components.Forms
@using PoemApp.Client.ApiClients
@using System.Collections.Generic
@inject PoemApiClient PoemClient
@inject AuthorsApiClient AuthorsClient
@inject CategoriesApiClient CategoriesClient
@inject NavigationManager Navigation
@inject ISnackbar Snackbar

<MudPaper Class="pa-4 mx-auto" Style="max-width:900px">
    <MudText Typo="Typo.h5">诗文编辑</MudText>

    <EditForm Model="_model" OnValidSubmit="HandleValid" OnInvalidSubmit="HandleInvalid">
        <DataAnnotationsValidator />
        <ValidationSummary />

        <MudTextField @bind-Value="_model.Title" Label="标题" Required="true" />
        <MudSelect T="int" Label="作者" @bind-Value="_model.AuthorId" Required="true">
            @foreach (var a in _authors)
            {
                <MudSelectItem T="int" Value="@a.Id">@a.Name</MudSelectItem>
            }
        </MudSelect>

        <MudSelect T="DynastyEnum" Label="朝代" @bind-Value="_model.Dynasty" Required="true">
            @foreach (DynastyEnum d in Enum.GetValues(typeof(DynastyEnum)))
            {
                <MudSelectItem T="DynastyEnum" Value="@(d)">@PoemApp.Core.Extensions.EnumExtensions.GetDisplayName(d)</MudSelectItem>
            }
        </MudSelect>

        <MudText Typo="Typo.subtitle1" Class="mt-2">分类</MudText>

        @* 按 Group 分组显示分类，保留父子层级并显示复选框 *@
        @foreach (var group in _displayOrder)
        {
            var groupNodes = BuildTreeListForGroup(group);
            if (!groupNodes.Any()) continue;

            <MudPaper Class="pa-2 mb-2" Elevation="0">
                <MudText Typo="Typo.subtitle2" Class="mb-1">@group.GetDisplayName()</MudText>

                <div>
                    @foreach (var node in groupNodes)
                    {
                        var sel = _categorySelections.FirstOrDefault(s => s.Id == node.Id);
                        <div class="d-flex align-center" style="gap:8px; padding-left:@(node.Level * 16)px;">
                            <input type="checkbox" id="cat-@node.Id" checked="@sel?.Checked" @onchange="@(e => ToggleCategoryChangedById(node.Id, e))" />
                            <label for="cat-@node.Id">@node.Name</label>
                        </div>
                    }
                </div>
            </MudPaper>
        }

        <MudText Typo="Typo.subtitle1" Class="mt-2">内容（纯文本）</MudText>
        <MudTextField TextFieldStyle="TextFieldStyle.Outlined" @bind-Value="_model.Content" Lines="6" Placeholder="请输入诗文文本（纯文本）"/>

        <MudText Typo="Typo.subtitle1" Class="mt-2">拼音（带音调）</MudText>
        <MudTextField TextFieldStyle="TextFieldStyle.Outlined" @bind-Value="_model.Pinyin" Lines="6" Placeholder="可手工编辑或粘贴"/>
        <div class="mt-2">
            <MudButton Variant="Variant.Text" Color="Color.Primary" OnClick="ValidatePinyin">校验对齐</MudButton>
        </div>

        <MudText Typo="Typo.subtitle1" Class="mt-2">对齐预览（上：拼音；下：正文）</MudText>
        <MudTextField TextFieldStyle="TextFieldStyle.Outlined" Value="@GetAlignedPreview()" Lines="12" ReadOnly="true" Class="font-monospace" />

        <MudText Typo="Typo.subtitle1" Class="mt-2">译文</MudText>
        <QuillEditor @ref="_translationEditor" InitialContent="@(_model.Translation ?? string.Empty)" />

        <MudText Typo="Typo.subtitle1" Class="mt-2">注释</MudText>
        <QuillEditor @ref="_annotationEditor" InitialContent="@(_model.Annotation ?? string.Empty)" />

        <MudText Typo="Typo.subtitle1" Class="mt-2">作品鉴赏</MudText>
        <QuillEditor @ref="_appreciationEditor" InitialContent="@(_model.Appreciation ?? string.Empty)" />

        <MudText Typo="Typo.subtitle1" Class="mt-2">背景</MudText>
        <QuillEditor @ref="_backgroundEditor" InitialContent="@(_model.Background ?? string.Empty)" />

        <div class="mt-3">
            <MudButton ButtonType="ButtonType.Submit" Variant="Variant.Filled">保存</MudButton>
            <MudButton Variant="Variant.Text" Color="Color.Error" OnClick="Delete">删除</MudButton>
            <MudButton Variant="Variant.Text" OnClick="Cancel">取消</MudButton>
        </div>
    </EditForm>
</MudPaper>

@code {
    [Parameter] public int Id { get; set; }

    private CreatePoemDto _model = new();
    private QuillEditor? _translationEditor;
    private QuillEditor? _annotationEditor;
    private QuillEditor? _appreciationEditor;
    private QuillEditor? _backgroundEditor;
    private List<AuthorDto> _authors = new();
    private List<CategoryDto> _categories = new();

    // selection wrapper so each checkbox binds to a concrete property
    private record CategorySelection(int Id, string Name, int? ParentId)
    {
        public bool Checked { get; set; }
    }

    private List<CategorySelection> _categorySelections = new();

    // 分组显示顺序
    private readonly CategoryGroup[] _displayOrder = new[]
    {
        CategoryGroup.EducationLevel,
        CategoryGroup.LiteraryForm,
        CategoryGroup.Dynasty,
        CategoryGroup.Theme,
        CategoryGroup.Style
    };

    protected override async Task OnInitializedAsync()
    {
        _authors = (await AuthorsClient.GetAllAsync()).Items.ToList();
        _categories = await CategoriesClient.GetAllAsync();

        // initialize selections from categories (unchecked by default)
        _categorySelections = _categories.Select(c => new CategorySelection(c.Id, c.Name, c.ParentId)).ToList();

        if (Id != 0)
        {
            var dto = await PoemClient.GetByIdAsync(Id);
            if (dto != null)
            {
                _model = new CreatePoemDto
                {
                    Title = dto.Title,
                    AuthorId = dto.AuthorId,
                    Dynasty = dto.Dynasty,
                    Background = dto.Background,
                    Translation = dto.Translation,
                    Annotation = dto.Annotation,
                    Appreciation = dto.Appreciation,
                    Content = dto.Content,
                    Pinyin = dto.Pinyin,
                    CategoryIds = (dto.CategoryIds != null && dto.CategoryIds.Count > 0)
                        ? dto.CategoryIds
                        : dto.Categories.Select(cn => _categories.FirstOrDefault(c => c.Name == cn)?.Id ?? 0).Where(x => x > 0).ToList()
                };

                // mark selections checked according to model.CategoryIds
                var set = new HashSet<int>(_model.CategoryIds);
                foreach (var sel in _categorySelections)
                {
                    sel.Checked = set.Contains(sel.Id);
                }
            }
        }
        else
        {
            // If creating and authors list not empty, optionally preselect first author to help validation UX
            if (_authors.Any())
            {
                _model.AuthorId = _authors.First().Id;
            }
        }
    }

    private void OnCategoryToggled(int categoryId, bool isChecked)
    {
        // kept for any side-effects; actual saving reads from _categorySelections
    }

    private void HandleInvalid(EditContext editContext)
    {
        var errors = editContext.GetValidationMessages().ToList();
        if (errors.Any())
        {
            var msg = string.Join(';', errors.Take(5));
            Snackbar.Add("表单验证失败: " + msg, Severity.Warning);
        }
        else
        {
            Snackbar.Add("表单验证失败，请检查输入", Severity.Warning);
        }
    }

    private Task OnEditorContentChanged(string html)
    {
        // no-op: rich editor replaced by plain textarea
        return Task.CompletedTask;
    }

    private async Task HandleValid()
    {
        // content is plain text already bound to _model.Content

        // sync selected categories into model from selection wrappers
        _model.CategoryIds = _categorySelections.Where(s => s.Checked).Select(s => s.Id).ToList();

        try
        {
            if (Id == 0)
            {
                var created = await PoemClient.CreateAsync(_model);
                if (created != null)
                {
                    Snackbar.Add("创建成功", Severity.Success);
                    Navigation.NavigateTo("/poems");
                }
                else Snackbar.Add("创建失败", Severity.Error);
            }
            else
            {
                var ok = await PoemClient.UpdateAsync(Id, new UpdatePoemDto {
                    Title = _model.Title,
                    Content = _model.Content,
                    AuthorId = _model.AuthorId,
                    Dynasty = _model.Dynasty,
                    Background = _model.Background,
                    Translation = _model.Translation,
                    Annotation = _model.Annotation,
                    Appreciation = _model.Appreciation,
                    Pinyin = _model.Pinyin,
                    CategoryIds = _model.CategoryIds
                });
                if (ok) { Snackbar.Add("更新成功", Severity.Success); Navigation.NavigateTo("/poems"); }
                else Snackbar.Add("更新失败", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add("保存失败: " + ex.Message, Severity.Error);
        }
    }

    private async Task Delete()
    {
        if (Id == 0) return;
        var ok = await PoemClient.DeleteAsync(Id);
        if (ok) { Snackbar.Add("删除成功", Severity.Success); Navigation.NavigateTo("/poems"); }
        else Snackbar.Add("删除失败", Severity.Error);
    }

    private void Cancel() => Navigation.NavigateTo("/poems");

    private async Task ToggleCategoryChangedById(int id, ChangeEventArgs e)
    {
        bool isChecked = false;
        if (e?.Value is bool b) isChecked = b;
        else if (e?.Value is string s) isChecked = s == "true" || s == "on";

        var sel = _categorySelections.FirstOrDefault(x => x.Id == id);
        if (sel != null) sel.Checked = isChecked;

        // if checked, ensure parent chain is also checked
        if (isChecked && sel?.ParentId.HasValue == true)
        {
            var parentId = sel.ParentId.Value;
            while (true)
            {
                var parentSel = _categorySelections.FirstOrDefault(x => x.Id == parentId);
                if (parentSel == null) break;
                if (!parentSel.Checked) parentSel.Checked = true;
                if (!parentSel.ParentId.HasValue) break;
                parentId = parentSel.ParentId.Value;
            }
        }

        await InvokeAsync(StateHasChanged);
    }

    // 构建指定 group 的树形列表，返回(ID, Name, Level)
    private List<(int Id, string Name, int Level)> BuildTreeListForGroup(CategoryGroup group)
    {
        var list = new List<(int, string, int)>();
        var groupCats = _categories.Where(c => c.Group == group).ToList();
        var lookup = groupCats.ToLookup(c => c.ParentId);

        // roots: parent is null or parent not in same group
        var roots = groupCats.Where(c => !c.ParentId.HasValue || !groupCats.Any(gc => gc.Id == c.ParentId)).OrderBy(c => c.Name).ToList();

        void Traverse(CategoryDto node, int level)
        {
            list.Add((node.Id, node.Name, level));
            foreach (var child in lookup[node.Id].OrderBy(c => c.Name))
            {
                Traverse(child, level + 1);
            }
        }

        foreach (var r in roots)
        {
            Traverse(r, 0);
        }

        return list;
    }

    private void ValidatePinyin()
    {
        var content = _model.Content ?? string.Empty;
        var pinyin = _model.Pinyin ?? string.Empty;

        // 跳过空内容校验
        if (string.IsNullOrWhiteSpace(content) || string.IsNullOrWhiteSpace(pinyin))
        {
            Snackbar.Add("原文或拼音不能为空，无法校验", Severity.Warning);
            return;
        }

        // 1. 校验换行数量一致（核心：行对行）
        var contentLines = content.Split('\n').Where(line => !string.IsNullOrWhiteSpace(line.Trim())).ToList();
        var pinyinLines = pinyin.Split('\n').Where(line => !string.IsNullOrWhiteSpace(line.Trim())).ToList();

        if (contentLines.Count != pinyinLines.Count)
        {
            Snackbar.Add($"对齐失败：原文{contentLines.Count}行，拼音{pinyinLines.Count}行，请让每行诗句对应一行拼音", Severity.Error);
            return;
        }

        // 2. 逐行校验：标点一致 + 有效字符数=拼音token数（不自动拆分，只提示）
        var errorLines = new List<int>();
        for (int i = 0; i < contentLines.Count; i++)
        {
            var lineNum = i + 1;
            var contentLine = contentLines[i].Trim();
            var pinyinLine = pinyinLines[i].Trim();

            // 2.1 校验标点一致（只比数量，不比对具体位置，简化逻辑）
            int contentPunctCount = contentLine.Count(c => IsPunctuation(c));
            int pinyinPunctCount = pinyinLine.Count(c => IsPunctuation(c));
            if (contentPunctCount != pinyinPunctCount)
            {
                errorLines.Add(lineNum);
                continue;
            }

            // 2.2 校验有效汉字数=拼音token数（已修复调用方式）
            int contentCharCount = contentLine.Count(c => !IsPunctuation(c)); // 过滤标点后的汉字数
            int pinyinTokenCount = ReplacePunctuations(pinyinLine) // 这里改了！
                                  .Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
                                  .Length; // 按空格拆分的token数

            if (contentCharCount != pinyinTokenCount)
            {
                errorLines.Add(lineNum);
            }
        }

        // 3. 汇总结果
        if (errorLines.Any())
        {
            var lineStr = string.Join("、", errorLines);
            Snackbar.Add($"第{lineStr}行对齐失败！请确保：1. 标点数量和原文一致；2. 每个汉字对应1个空格分隔的拼音", Severity.Error);
            return;
        }

        // 所有校验通过
        Snackbar.Add("对齐校验通过！", Severity.Success);
    }

    #region 简化版辅助方法（只保留核心功能）
    /// <summary>
    /// 判断是否为全角标点（只保留常用的，不搞复杂）
    /// </summary>
    private static bool IsPunctuation(char c)
    {
        var punctuations = new[] { '，', '。', '！', '？', '；', '、' };
        return punctuations.Contains(c);
    }

    /// <summary>
    /// 过滤文本中的全角标点（用于统计token数）
    /// </summary>
    private static string ReplacePunctuations(string text)
    {
        var punctuations = new[] { '，', '。', '！', '？', '；', '、' };
        foreach (var p in punctuations)
        {
            text = text.Replace(p.ToString(), " ");
        }
        return text;
    }
    #endregion

    // 简化版预览（只保证“数量一致时对齐，不一致时提示”）
    private string GetAlignedPreview()
    {
        var p = _model.Pinyin ?? string.Empty;
        var c = _model.Content ?? string.Empty;

        // 按行拆分（行对行）
        var contentLines = c.Split('\n').Where(line => !string.IsNullOrWhiteSpace(line.Trim())).ToList();
        var pinyinLines = p.Split('\n').Where(line => !string.IsNullOrWhiteSpace(line.Trim())).ToList();

        var preview = new List<string>();
        preview.Add("=== 对齐预览（上：拼音；下：原文）===");

        for (int i = 0; i < Math.Max(contentLines.Count, pinyinLines.Count); i++)
        {
            var pLine = i < pinyinLines.Count ? pinyinLines[i].Trim() : "";
            var cLine = i < contentLines.Count ? contentLines[i].Trim() : "";

            // 1. 过滤标点，拆分拼音token和汉字
            var pTokens = ReplacePunctuations(pLine)
                          .Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
                          .ToList();
            var cChars = cLine.Where(ch => !IsPunctuation(ch))
                              .Select(ch => ch.ToString())
                              .ToList();

            // 2. 数量不一致时，直接提示
            if (pTokens.Count != cChars.Count)
            {
                preview.Add($"⚠️  第{i + 1}行数量不匹配：");
                preview.Add(pLine);
                preview.Add(cLine);
                preview.Add("");
                continue;
            }

            // 3. 逐字生成“固定宽度+居中”的对齐块（用空格填充，确保每个占位宽度一致）
            const int fixedWidth = 8; // 每个拼音/汉字的固定宽度（可根据字体调整）
            string PadCenter(string s)
            {
                // 居中对齐：左右补空格，总长度为fixedWidth
                var spaceCount = fixedWidth - s.Length;
                var left = spaceCount / 2;
                var right = spaceCount - left;
                return new string(' ', left) + s + new string(' ', right);
            }

            // 生成拼音行和原文行
            var pAligned = string.Join("", pTokens.Select(t => PadCenter(t)));
            var cAligned = string.Join("", cChars.Select(ch => PadCenter(ch)));

            preview.Add(pAligned);
            preview.Add(cAligned);
            preview.Add(""); // 行间距
        }

        return string.Join("\n", preview);
    }
}
